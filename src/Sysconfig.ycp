/**
 * File:	modules/Sysconfig.ycp
 * Package:	Configuration of sysconfig
 * Summary:	Data for configuration of sysconfig, input and output functions.
 * Authors:	Ladislav Slezak <lslezak@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of sysconfig.
 * Input and output routines.
 */

{

module "Sysconfig";
textdomain "sysconfig";

import "Progress";
import "Report";
import "Summary";
import "Directory";
import "Product";
import "Label";

include "sysconfig/routines.ycp";
include "network/ip.ycp";

global list configfiles = ["/etc/sysconfig/*", "/etc/sysconfig/network/ifcfg-*",
    "/etc/sysconfig/network/wireless", "/etc/sysconfig/network/dhcp",
    "/etc/sysconfig/network/config", Directory::ydatadir + "/descriptions"];

// Additional files from Import
list custom_files = [];

// all read variables
map variables = $[];

// modified variables
map modified_variables = $[];

// comment for non-variable nodes
map node_comments = $[];

// location for each variable
map variable_locations = $[];

global map parse_param = $[
    "separator" : ",",
    "unique" : true,
    "remove_whitespace" : true
];

global list tree_content = [];

global boolean powertweak_mode = false;

// map of actions to start when variable is modified
map actions = $[];

global boolean ConfirmActions = false;


/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Data was modified?
 * @return true if modified
 */
global define boolean Modified() ``{
    return (size(modified_variables) > 0);
};

/**
 * Search in syscnfig files for value
 * @param params search parameters
 * @param show_progress if true progress bar will be displayed
 * @return list(string) List of found variables (IDs)
 */
global define list(string) search(map params, boolean show_progress) ``{
    list(string) found = [];

    // get all configuration files
    list(string) files = SCR::Dir(.syseditor.section);

    if (show_progress == true)
    {
	// Translation: Progress bar label
	UI::OpenDialog(`ProgressBar(`id(`progress), _("Searching..."), size(files), 0));
    }

    boolean search_varname = params["varname"]:true;
    boolean search_description = params["description"]:false;
    boolean search_value = params["value"]:false;
    boolean case_insensitive = params["insensitive"]:false;
    string search_string = params["search"]:"";

    if (search_string == "")
    {
	return found;
    }

    if (case_insensitive == true)
    {
	search_string = tolower(search_string);
    }

    integer index = 0;

    foreach(string file, files, ``{
	    // get all variables in file
	    path var_path = add(.syseditor.value, file);
	    list variables = SCR::Dir(var_path);

	    y2debug("Searching in file %1", file);

	    foreach(string var, variables,
		``{
		    boolean already_found = false;

		    y2debug("Searching in variable %1", var);

		    if (search_varname == true)
		    {
			string var2 = var;
			if (case_insensitive)
			{
			    var2 = tolower(var);
			}

			if (issubstring(var2, search_string))
			{
			    found = add(found, var + "$" + file);
			    already_found = true;
			}
		    }

		    // search in variable value if it is requested and previous check was unsuccessful
		    if (search_value == true && already_found == false)
		    {
			string read_value = SCR::Read(add(add(.syseditor.value, file), var));

			if (case_insensitive)
			{
			    read_value = tolower(read_value);
			}

			if (issubstring(read_value, search_string))
			{
			    found = add(found, var + "$" + file);
			    already_found = true;
			}
		    }

		    if (search_description == true && already_found == false)
		    {
			// read comment without metadata
			string read_comment = get_only_comment(SCR::Read(add(add(.syseditor.value_comment, file), var)));

			if (case_insensitive)
			{
			    read_comment = tolower(read_comment);
			}

			if (issubstring(read_comment, search_string))
			{
			    found = add(found, var + "$" + file);
			}
		    }
		}
	    );

	    if (show_progress == true)
	    {
		index = index + 1;
		UI::ChangeWidget(`id(`progress), `Value, index);
	    }

	}
    );

    if (show_progress == true)
    {
	UI::CloseDialog();
    }

    y2debug("Found: %1", found);

    return found;
}

/**
 * Remove white spaces at beginning or at the end of string
 * @param input Input string
 * @return string String without white spaces
 */
global define string remove_whitespaces(string input) ``{
    if (input == nil)
    {
	return nil;
    }

    string removed_whitespaces = regexpsub(input, "^[ \t]*(([^ \t]*[ \t]*[^ \t]+)*)[ \t]*$", "\\1");

    return (removed_whitespaces != nil) ? removed_whitespaces : input;
}

/**
 * Parse string of values - split string to values, quoting and backslash sequences are supported
 * @param options Input string
 * @param parameters Parmeter used at parsing - map with keys:
 *	"separator":<string> - value separator (default: " \t"),
 *	"unique":<boolean> - result will not contain any duplicates, first occurance of the string is stored into output (default: false),
 *	"interpret_backslash":<boolean> - convert backslash sequence into one character (e.g. "\\n" => "\n") (default: true)
 *	"remove_whitespace":<boolean> - remove white spaces around values (default: false),
 *	"remove_empty_strings":<boolean> - remove empty strings from result (default: true)
 * @return list List of strings
 * @see ParseString.txt documenation
 */
global define list ParseString(string options, map parameters) ``{
    list ret = [];

    // parsing options
    string separator = parameters["separator"]:" \t";
    boolean unique = parameters["unique"]:false;
    boolean interpret_backslash = parameters["interpret_backslash"]:true;
    boolean remove_whitespace = parameters["remove_whitespace"]:false;
    boolean remove_empty_strings = parameters["remove_empty_strings"]:true;

    y2debug("Input: string: '%1', parameters: %2", options, parameters);
    y2debug("Used values: separator: '%1', unique: %2, remove_empty_strings: %3, remove_whitespace: %4", separator, unique, remove_empty_strings, remove_whitespace);

    if (options == nil)
    {
	return [];
    }

    // two alghorithms are used:
    // first is much faster, but only usable if string
    // doesn't contain any double qoute characters
    // and backslash sequences are not interpreted
    // second is more general, but of course slower

    if (findfirstof(options, "\"") == nil && interpret_backslash == false)
    {
	// easy case - no qouting, don't interpres backslash sequences => use splitstring
	list(string) values = splitstring(options, separator);

	foreach (string v, values, ``{
		if (remove_whitespace == true)
		{
		    v = remove_whitespaces(v);
		}

		if (unique == true)
		{
		    if (!contains(ret, v)) ret = add(ret, v);
		}
		else
		{
		    ret = add(ret, v);
		}
	    }
	);
    }
    else
    {
	// quoting is used or backslash interpretation is enabled
	// so it' not possible to split input
	// parsing each character is needed - use finite automaton

	// state
	symbol state = `out_of_string;
	// position in the input string
	integer index = 0;
	// parsed value
	string str = "";

	while(index < size(options))
	{
	    string character = substring(options, index, 1);

	    y2debug("character: %1 state: %2 index: %3", character, state, index);

	    // interpret backslash sequence
	    if (character == "\\" && interpret_backslash == true)
	    {
		if (index + 1 < size(options))
		{
		    string nextcharacter = substring(options, index + 1, 1);
		    index = index + 1;

		    // backslah sequences
		    map backslash_seq = $[
			"a"	: "\a",	// alert
			"b"	: "\b", // backspace
			"e"	: "\e", // escape
			"f"	: "\f", // FF
			"n"	: "\n", // NL
			"r"	: "\r", // CR
			"t"	: "\t", // tab
			"v"	: "\v", // vertical tab
			"\\"	: "\\", // backslash
		    ];

		    if (haskey(backslash_seq, nextcharacter) == true)
		    {
			character = backslash_seq[nextcharacter]:"DUMMY";
		    }
		    else
		    {
			if (nextcharacter != "\"")
			{
			    // ignore backslash in invalid backslash sequence
			    character = nextcharacter;
			}
			else
			{
			    // backslash will be removed later,
			    // double quote and escaped double quote have to different yet
			    character = "\\\"";
			}
		    }

		    y2debug("backslash sequnce: '%1'", character);
		}
		else
		{
		    y2warning("Missing character after backslash (\\) at the end of string");
		}
	    }

	    if (state == `out_of_string)
	    {
		if (issubstring(separator, character) == true)
		{
		    index = index + 1;
		    continue;
		}
		else if (character == "\"")
		{
		    state = `in_quoted_string;
		}
		else
		{
		    state = `in_string;

		    if (character == "\\\"")
		    {
			str = "\"";
		    }
		    else
		    {
			str = character;
		    }
		}
	    }
	    else if (state == `in_quoted_string)
	    {
		if (character == "\"")
		{
		    state = `out_of_string;
		    state = `in_string;

		    if (unique == true)
		    {
			if (!contains(ret, str)) ret = add(ret, str);
		    }
		    else
		    {
			ret = add(ret, str);
		    }

		    str = "";
		}
		else if (character == "\\\"")
		{
		    str = str + "\"";
		}
		else
		{
		    str = str + character;
		}
	    }
	    else if (state == `in_string)
	    {
		if (issubstring(separator, character) == true)
		{
		    state = `out_of_string;

		    if (remove_whitespace == true)
		    {
			str = remove_whitespaces(str);
		    }

		    if (unique == true)
		    {
			if (!contains(ret, str)) ret = add(ret, str);
		    }
		    else
		    {
			ret = add(ret, str);
		    }

		    str = "";
		}
		else if (character == "\\\"")
		{
		    str = str + "\"";
		}
		else
		{
		    str = str + character;
		}
	    }

	    index = index + 1;
	}

	if (state == `in_quoted_string)
	{
	    y2warning("Missing trainling double quote character(\") in input: '%1'", options);

	    if (unique == true)
	    {
		if (!contains(ret, str)) ret = add(ret, str);
	    }
	    else
	    {
		ret = add(ret, str);
	    }
	}

	if (state == `in_string)
	{
	    if (remove_whitespace)
	    {
		str = remove_whitespaces(str);
	    }

	    if (unique == true)
	    {
		if (!contains(ret, str)) ret = add(ret, str);
	    }
	    else
	    {
		ret = add(ret, str);
	    }
	}
    }

    if (remove_empty_strings == true)
    {
	ret = filter(string val, ret, ``(val != "" && val != nil));
    }

    y2debug("Parsed values: %1", ret);

    return ret;
}

/**
 * Get description of selected variable
 * @param varid Variable identification
 * @return map Description map
 */

global define map get_description(string varid) ``{
    string varname = get_name_from_id(varid);
    string fname = get_file_from_id(varid);

    path comment_path = add(add(.syseditor.value_comment, fname), varname);
    path value_path = add(add(.syseditor.value, fname), varname);
    string comment = SCR::Read(comment_path);
    list all_variables = SCR::Dir(add(.syseditor.value, fname));
    string used_comment = varname;

    // no comment present
    if (size(comment) == 0 && !regexpmatch(fname, "^/etc/sysconfig/network/ifcfg-.*"))
    {
	y2warning("Comment for variable %1 is missing", varid);

	list reversed = [];

	integer i = 0;
	boolean found = false;

	while (i < size(all_variables) && found == false)
	{
	    string v = all_variables[i]:"";

	    if (v == varname)
	    {
		found = true;
	    }
	    else
	    {
		reversed = prepend(reversed, v);
	    }

	    i = i + 1;
	}

	if (found == true)
	{
	    i = 0;
	    comment = "";
	    string v = "";

	    y2debug("reversed: %1", reversed);
	    while (i < size(reversed) && comment == "")
	    {
		v = reversed[i]:"";
		used_comment = v;
		comment = SCR::Read(add(add(.syseditor.value_comment, fname), v));

		i = i + 1;
	    }

	    y2warning("Variable: %1 Using comment from variable: %2", varname, v);
	}

    }

    // remove config file header at the beginning of the file
    // header is comment from beginning of the file to the empty line
    if (used_comment == all_variables[0]:"" && comment != nil)
    {
	y2debug("Reading first variable from the file");
	// comment is read from the first variable
	// remove header if it's present
	y2debug("Whole comment: %1", comment);
	list(string) lines = splitstring(comment, "\n");
	list filtered = [];

	// remove last empty string from list (caused by last new line char)
	if (lines[size(lines) - 1]:nil == "")
	{
	    lines = remove(lines, size(lines) - 1);
	}

	if (contains(lines, "") == true)
	{
	    y2milestone("Header comment detected");
	    boolean adding = false;

	    // filter out variables before empty line
	    filtered = filter(string line, lines, ``{

		    if (line == "")
		    {
			adding = true;
		    }
		    else if (adding == true)
		    {
			return true;
		    }

		    return false;
		}
	    );

	    // merge strings
	    comment = mergestring(filtered, "\n");
	}
    }

    map meta = parse_metadata(comment);

    string template_only_comment = "";

    // for network configuration file read comments from configuration template
    if (regexpmatch(fname, "^/etc/sysconfig/network/ifcfg-.*"))
    {
	string template_comment = SCR::Read(add(add(.sysconfig.network.template, "value_comment"), varname));
	map template_meta = parse_metadata(template_comment);

	if (size(template_meta) > 0)
	{
	    // add missing metadata values from template
	    foreach(string key, string value, template_meta, ``{
		    if (!haskey(meta, key))
		    {
			meta[key] = value;
		    }
		}
	    );
	}

	template_only_comment = get_only_comment(template_comment);

	if (size(template_only_comment) > 0)
	{
	    template_only_comment = template_only_comment + "\n";
	}

	y2milestone("Comment read from template: %1", template_only_comment);
	y2milestone("Meta read from template: %1", template_meta);
    }

    string deflt = meta["Default"]:nil;

    if (deflt != nil)
    {
	list parsed = ParseString(deflt, parse_param);
	meta["Default"] = parsed[0]:"";

	y2debug("Read default value: %1", parsed[0]:"");
    }

    string new_value = modified_variables[varid]:nil;

    // check if value was changed
    if (new_value != nil)
    {
	meta["new_value"] = new_value;
    }

    meta["name"] = varname;
    meta["file"] = get_file_from_id(varid);
    meta["location"] = (varname != "") ? get_location_from_id(varid) : varid;
    meta["comment"] = (varname != "") ? template_only_comment + get_only_comment(comment) : (node_comments[varid]:"");
    meta["value"] = SCR::Read(value_path);

    // add action commands
    if (size(actions[varid]:$[]) > 0)
    {
	meta["actions"] = actions[varid]:$[];
    }

    return meta;
}

/**
 * Parse metadata from comment
 * @param comment Input comment
 * @return map parsed metadata
 */
global define map parse_metadata(string comment) ``{
    map ret = $[];

    // get metadata part of comment
    list metalines = get_metadata(comment);
    list joined_multilines = [];
    string multiline = "";

    y2debug("metadata: %1", metalines);

    // join multi line metadata lines
    foreach(string metaline, metalines, ``{
	    if (substring(metaline, size(metaline) - 1, 1) != "\\")
	    {
		if (multiline != "")
		{
		    // this not first multiline so remove comment mark
		    string without_comment = regexpsub(metaline, "^##(.*)", "\\1");

		    if (without_comment != nil)
		    {
			metaline = without_comment;
		    }
		}
		joined_multilines = add(joined_multilines, multiline + metaline);
		multiline = "";
	    }
	    else
	    {
		string part = substring(metaline, 0, size(metaline) - 1);

		if (multiline != "")
		{
		    // this not first multiline so remove comment mark
		    string without_comment = regexpsub(part, "^##(.*)", "\\1");

		    if (without_comment != nil)
		    {
			part = without_comment;
		    }
		}

		// add line to the previous lines
		multiline = multiline + part;
	    }
	}
    );

    y2debug("metadata after multiline joining: %1", joined_multilines);

    // parse each metadata line
    foreach(string metaline, joined_multilines, ``{

	    /* Ignore lines with ### -- general comments */
	    if (regexpmatch(metaline, "^###"))
	    {
		return;
	    }

	    string meta = regexpsub(metaline, "^##[ \t]*(.*)", "\\1");

	    // split sting to the tag and value part
	    integer colon_pos = findfirstof(meta, ":");
	    string tag = "";
	    string val = "";

	    if (colon_pos == nil)
	    {
		// colon is missing
		tag = meta;
	    }
	    else
	    {
		tag = substring(meta, 0, colon_pos);

		if (size(meta) > colon_pos + 1)
		{
		    val = substring(meta, colon_pos + 1);
		}
	    }

	    // remove whitespaces from parts
	    tag = remove_whitespaces(tag);
	    val = remove_whitespaces(val);

	    y2milestone("tag: %1 val: '%2'", tag, val);

	    // add tag and value to map if they are present in comment
	    if (tag != "")
	    {
		ret = add(ret, tag, val);
	    }
	    else
	    {
		// ignore separator lines
		if (!regexpmatch(metaline, "^#*$"))
		{
		    y2warning("Unknown metadata line: %1", metaline);
		}
	    }
	}
    );

    return ret;
}

/**
 * Get metadata lines from input string
 * @param input Input string
 * @return list(string) Metadata lines in list
 */
global define list(string) get_metadata(string input) ``{
    if (input == nil || input == "")
    {
	return [];
    }

    list(string) lines = splitstring(input, "\n");
    return (filter(string line, lines, ``(regexpmatch(line, "^##.*"))));
}

/**
 * Get comment without metadata
 * @param input Input string
 * @return string Comment used as variable description
 */
global define string get_only_comment(string input) ``{
    if (input == nil || input == "")
    {
	return "";
    }

    list(string) lines = splitstring(input, "\n");

    string ret = "";

    foreach(string line, lines, ``{
	    string com_line = regexpsub(line, "^#([^#].*)", "\\1");

	    if (com_line == nil)
	    {
		// add empty lines
		if (regexpmatch(line, "^#[ \t]*$") == true)
		{
		    ret = ret + "\n";
		}
	    }
	    else
	    {
		ret = ret + com_line + "\n";
	    }
	}
    );

    return ret;
}

/**
 * Get variable name from variable identification or empty string if input is invalid
 * @param id Variable identification
 * @return string Variable name
 * @example get_name_from_id("var$file") -> "var"
 */
global define string get_name_from_id(string id) ``{

    if (id == nil)
    {
	return "";
    }

    integer pos = findfirstof(id, "$");

    if (pos >= 0)
    {
	return substring(id, 0, findfirstof(id, "$"));
    }
    else
    {
	return "";
    }
}

/**
 * Get variable location in tree widget from variable identification
 * @param id Variable identification
 * @return string Variable location
 */
global define string get_location_from_id(string id) ``{
    return variable_locations[id]:"";
}

/**
 * Get file name where is variable located from variable identification
 * @param id Variable identification
 * @return string File name
 */
global define string get_file_from_id(string id) ``{
    if (id == nil)
    {
	return "";
    }

    integer pos = findfirstof(id, "$");

    if (pos >= 0)
    {
	return substring(id, pos + 1);
    }
    else
    {
	return "";
    }
}

/**
 * Set new variable value
 * @param variable Variable identification
 * @param new_value New value
 * @param force If true - do not check if new value is valid
 * @param force_change Force value as changed even if it is equal to old value
 * @return symbol Result: `not_found (specified variable was not found in config file),
 *   `not_valid (new  value is not valid - doesn't match variable type definition),
 *   `ok (success)
 */
global define symbol set_value(string variable, string new_value, boolean force, boolean force_change) ``{
    map desc = get_description(variable);
    string name = get_name_from_id(variable);

    if (name == "")
    {
	return `not_found;
    }

    string modif = modified_variables[variable]:nil;
    string old = desc["value"]:"";

    string curr_val = (modif != nil) ? modif : old;

    if (force_change || new_value != curr_val)
    {
	y2milestone("variable: %1 changed from: %2 to: %3", variable, curr_val, new_value);

	if (new_value == old && !force_change)
	{
	    // variable was reset to the original value, remove it from map of modified
	    y2debug("Variable %1 was reset to the original value", variable);
	    modified_variables = remove(modified_variables, variable);
	}
	else
	{
	    boolean valid = false;

	    if (force == false)
	    {
		// check data type
		string type = desc["Type"]:"string";

		if (type == "string" || regexpmatch(type, "^string\\(.*\\)$") == true)
		{
		    // string type is valid always
		    valid = true;
		}
		else if (type == "yesno")
		{
		    valid = (new_value == "yes" || new_value == "no");
		}
		else if (type == "boolean")
		{
		    valid = (new_value == "true" || new_value == "false");
		}
		else if (type == "integer")
		{
		    valid = regexpmatch(new_value, "^-{0,1}[0-9]*$");

		}
		else if (regexpmatch(type, "^list\\(.*\\)$"))
		{
		    string listopt = regexpsub(type, "^list\\((.*)\\)$", "\\1");
		    list parsed_opts = ParseString(listopt, parse_param);

		    valid = contains(parsed_opts, new_value);
		}
		else if (regexpmatch(type, "^integer\\(-{0,1}[0-9]*:-{0,1}[0-9]*\\)$"))
		{
		    // check if input is integer
		    valid = regexpmatch(new_value, "^-{0,1}[0-9]*$");

		    if (valid == true)
		    {
			// it is integer, check range
			string min = regexpsub(type, "^integer\\((-{0,1}[0-9]*):-{0,1}[0-9]*\\)$", "\\1");
			string max = regexpsub(type, "^integer\\(-{0,1}[0-9]*:(-{0,1}[0-9]*)\\)$", "\\1");

			y2milestone("min: %1  max: %2", min, max);

			integer min_int = tointeger(min);
			integer max_int = tointeger(max);
			integer new_int = tointeger(new_value);

			y2milestone("min_int: %1  max_int: %2", min_int, max_int);

			if (max != "" && min != "")
			{
			    valid = (new_int >= min_int && new_int <= max_int);
			}
			else if (max == "")
			{
			    valid = (new_int >= min_int);
			}
			else if (min == "")
			{
			    valid = (new_int <= max_int);
			}
			else
			{
			    // empty range, valid is set to true
			    y2warning("empty integer range, assuming any integer");
			}
		    }
		}
		else if (regexpmatch(type, "^regexp\\(.*\\)$"))
		{
		    string regex = regexpsub(type, "^regexp\\((.*)\\)$", "\\1");
		    valid = regexpmatch(new_value, regex);
		}
		else if (type == "ip")
		{
		    // check IP adress using function from network/ip.ycp include
		    valid = check_ip(new_value);
		}
		else if (type == "ip4")
		{
		    // check IP adress using function from network/ip.ycp include
		    valid = check_ip4(new_value);
		}
		else if (type == "ip6")
		{
		    // check IP adress using function from network/ip.ycp include
		    valid = check_ip6(new_value);
		}
		else
		{
		    y2warning("Unknown data type %1 for variable %2", type, name);
		}
	    }

	    if (valid == false && force == false)
	    {
		return `not_valid;
	    }
	    else
	    {
		modified_variables[variable] = new_value;
		return `ok;
	    }
	}
    }

    // value was not changed => OK
    return `ok;
}

/**
 * Return modification status of variable
 * @param varid Variable identification
 * @return boolean True if variable was modified
 */
global define boolean modified(string varid) ``{
    return haskey(modified_variables, varid);
}

/**
 * Get list of modified variables
 * @return list List of modified variables
 */
global define list get_modified()
``{

    list ret = [];

    foreach(string varid, string new_value, modified_variables,
	``{
	    ret = add(ret, varid);
	}
    );

    return ret;
}

/**
 * Read all sysconfig settings
 * @param files list of files or directories to read. Directories are not read recursively.
 * @return true on success
 */
global define boolean Read(list(string) files) ``{

    string tmpdir = SCR::Read(.target.tmpdir);
    if (tmpdir == nil || tmpdir == "")
    {
	y2security("Using /tmp directory !");
	tmpdir = "/tmp";
    }

    // register configuration files in SCR using INI-agent
    string agentdef = sformat(".syseditor\n\n`ag_ini(IniAgent( %1,\n", files) + SCR::Read(.target.string, Directory::ydatadir + (powertweak_mode ? "/powertweak.agent" : "/sysedit.agent"));
    string tmp = tmpdir + "/sysconfig-agent.scr";

    SCR::Write(.target.string, tmp, agentdef);
    SCR::RegisterAgent(.syseditor, tmp);


    // register agent for reading network template
    agentdef = sformat(".sysconfig.network.template,\n\n`ag_ini(IniAgent(\"/etc/sysconfig/network/ifcfg.template\"\n,") + SCR::Read(.target.string, Directory::ydatadir + "/sysedit.agent");
    tmp = tmpdir + "/sysconfig-template-agent.scr";

    SCR::Write(.target.string, tmp, agentdef);
    SCR::RegisterAgent(.sysconfig.network.template, tmp);


    // list of all config files
    y2milestone("Registered config files: %1", SCR::Dir(.syseditor.section));

    // create script options
    string param = "";
    foreach(string par, files, ``{param = param + "'" + par + "' ";});

    // create tree definition list and description map using external Perl script
    SCR::Execute(.target.bash, Directory::bindir + "/parse_configs.pl " + (powertweak_mode ? "--powertweak " : "") + param + "> " + tmpdir + "/treedef.ycp");

    // read list
    list parsed_output = SCR::Read(.target.ycp, tmpdir + "/treedef.ycp");
    tree_content = parsed_output[0]:[];

    node_comments = parsed_output[1]:$[];

    variable_locations = parsed_output[2]:$[];

    // redefined variables (variables which are defined in more files)
    map redefined_vars = parsed_output[3]:$[];
    if (size(redefined_vars) > 0)
    {
	y2warning("Redefined variables: %1", redefined_vars);
    }

    // read map with activation commands
    actions = parsed_output[4]:$[];

    return true;
}

/**
 * Write all sysconfig settings
 * @return boolean true on success
 */
global define boolean Write() ``{

    // remember all actions - start each action only once
    map Configmodules = $[];
    map Restarted = $[];
    map Reloaded = $[];
    map Commands = $[];
    // will be complete SuSEconfig started?
    boolean CompleteSuSEconfig = false;

    // aborted?
    boolean abort = false;

    // SuSEconfig script name
    string SuSEconfigName = (Product::unitedlinux == true) ? "ULconfig" : "SuSEconfig";

    // there is no progress bar yet
    Progress::off();

    // start presave commands
    foreach (string vid, string new_val, modified_variables, ``{
	    if (abort)
	    {
		return;
	    }

	    // get activation map for variable
	    string presave = actions[vid, "Pre"]:nil;

	    if (size(presave) > 0)
	    {
		string confirm = _("A command will be executed");
		string label = sformat(_("Starting command: %1..."), presave);
		string error = sformat(_("Command %1 failed"), presave);

		symbol precommandresult = StartCommand(presave, label, error, confirm, ConfirmActions);

		if (precommandresult == `abort)
		{
		    abort = true;
		}
		else if (precommandresult == `failed)
		{
		    // PreSaveCommand returned non zero value
		    // remove activation data for failed variable
		    // (insert empty Command: to not start complete SuSEconfig)
		    actions[vid] = $["Cmd" : ""];
		}
		else if (precommandresult != `success && precommandresult != `skip)
		{
		    y2error("Unknown return value from StartCommand(): %1", precommandresult);
		}
	    }
	}
    );

    if (abort)
    {
	return false;
    }

    // reenable progress bar
	if (!write_only)
	     Progress::on();

    foreach (string vid, string new_val, modified_variables, ``{
	// get activation map for variable
	map activate = actions[vid]:$[];

	string restart_service = activate["Rest"]:nil;
	string reload_service = activate["Reld"]:nil;
	string config_module = activate["Cfg"]:nil;
	string bash_command = activate["Cmd"]:nil;

	if (config_module == nil && reload_service == nil && restart_service == nil && bash_command == nil && CompleteSuSEconfig == false)
	{
	    // start complete SuSEconfig (backward compatibility)
	    CompleteSuSEconfig = true;
	}
	else
	{
	    if (size(restart_service) > 0)
	    {
		list parsed = ParseString(restart_service, parse_param);
		foreach(string s, parsed,
		    ``{
			Restarted[s] = true;
		    }
		);
	    }

	    if (size(reload_service) > 0)
	    {
		list parsed = ParseString(reload_service, parse_param);
		foreach(string s, parsed,
		    ``{
			Reloaded[s] = true;
		    }
		);
	    }

	    if (size(config_module) > 0)
	    {
		list parsed = ParseString(config_module, parse_param);
		foreach(string s, parsed,
		    ``{
			Configmodules[s] = true;
		    }
		);
	    }

	    if (size(bash_command) > 0)
	    {
		Commands[bash_command] = true;
	    }
	}
    });

    // write dialog caption
    string caption = (powertweak_mode == true) ? _("Saving Powertweak Configuration") : _("Saving sysconfig Configuration");

    // set the right number of stages
    integer steps = (powertweak_mode == false) ? size(modified_variables) + size(Restarted) + size(Reloaded) + size(Commands) + ((CompleteSuSEconfig) ? 1 : size(Configmodules)) + 1 /* flush*/ + 3 /* 3 stages */ : size(modified_variables) + 2 /* 2 stages */;

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	// progress bar item
	    _("Write the new settings"),
	    _("Activate the changes")
	],
	nil,
	""
    );

    Progress::NextStage();

    boolean ret = true;

    // save each changed variable
    foreach (string vid, string new_val, modified_variables,
	``{
	    string file = get_file_from_id(vid);
	    string name = get_name_from_id(vid);
	    path value_path = add(add(.syseditor.value, file), name);

	    boolean written = SCR::Write(value_path, new_val);
	    if (written == false)
	    {
		// error popup: %1 - variable name (e.g. DISPLAYMANAGER), %2 - file name (/etc/sysconfig/displaymanager)
		Report::Error(sformat(_("Saving variable %1 to the file %2 failed."), name, file));
		ret = false;
	    }

	    // progress bar label, %1 is variable name (e.g. DISPLAYMANAGER)
	    Progress::Title(sformat(_("Saving variable %1..."), name));
	    Progress::NextStep();
	}
    );

    Progress::Title(_("Saving changes to the files..."));
    // flush changes
    SCR::Write(.syseditor, nil);
    Progress::NextStep();

    // now start required activation commands
    Progress::NextStage();

    // activate powertweak configuration
    if (powertweak_mode == true)
    {
	Progress::Title(sformat(_("Starting command: %1..."), "/usr/sbin/powertweakd --no-daemon"));

	y2milestone("Activating powertweak configuration");
	ret = SCR::Execute(.target.bash, "/usr/sbin/powertweakd --no-daemon");

	if (ret == false)
	{
	    return ret;
	}

	// activate powertweak at startup
	ret = Runlevel::ServiceAdjust("powertweakd", "enable");
	return ret;
    }

    // start SuSEconfig
    if (CompleteSuSEconfig == true)
    {
	// action command is missing, start complete SuSEconfig (backward compatibility)
	string start_command = sformat("/sbin/%1", SuSEconfigName);
	// %1 is SuSEconfig/ULconfig - product dependent
	string confirm = sformat(_("Complete %1 will be started"), SuSEconfigName);
	string label = sformat(_("Starting %1..."), SuSEconfigName);
	string error = sformat(_("Script %1 failed"), SuSEconfigName);

	Progress::NextStep();

	if (StartCommand(start_command, label, error, confirm, ConfirmActions) == `abort)
	{
	    return false;
	}
    }
    else if (size(Configmodules) > 0)
    {
	// start only required SuSEconfig modules
	foreach(string modulename, boolean dummy, Configmodules,
	``{
	    if (abort) return;

	    // action command is missing, start complete SuSEconfig (backward compatibility)
	    string start_command = sformat("/sbin/%1 --module %2", SuSEconfigName, modulename);
	    string confirm = sformat(_("%1 module %2 will be started"), SuSEconfigName, modulename);
	    // progress bar label - %1 is SuSEconfig or ULconfig string, %2 is module name
	    string label = sformat(_("Starting %1 module %2..."), SuSEconfigName, modulename);
	    // error message (config module failed) - %1 is SuSEconfig or ULconfig string, %2 is module name
	    string error = sformat(_("%1 module %2 failed"), SuSEconfigName, modulename);

	    Progress::NextStep();

	    if (StartCommand(start_command, label, error, confirm, ConfirmActions) == `abort)
	    {
		abort = true;
	    }
	}
	);
    }

    if (abort) return false;

    if (size(Reloaded) > 0)
    {
	// restart required services
	foreach(string servicename, boolean dummy, Reloaded,
	``{
	    if (abort) return;
	    // check whether service is running
	    string check_command = sformat("/etc/init.d/%1 status", servicename);
	    integer result = SCR::Execute(.target.bash, check_command);
	    y2milestone("%1 service status: %2", servicename, result);

	    if (result == 0)
	    {
		// service is running, reload it
		string start_command = sformat("/etc/init.d/%1 reload", servicename);
		string confirm = sformat(_("Service %1 will be reloaded"), servicename);
		string label = sformat(_("Reloading service %1..."), servicename);
		string error = sformat(_("Reload of the service %1 failed"), servicename);

		Progress::NextStep();

		if (StartCommand(start_command, label, error, confirm, ConfirmActions) == `abort)
		{
		    abort = true;
		}
	    }
	}
	);
    }

    if (abort) return false;

    if (size(Restarted) > 0)
    {
	// restart required services
	foreach(string servicename, boolean dummy, Restarted,
	``{
	    // check whether service is running
	    string check_command = sformat("/etc/init.d/%1 status", servicename);
	    integer result = SCR::Execute(.target.bash, check_command);
	    y2milestone("%1 service status: %2", servicename, result);

	    Progress::NextStep();

	    if (result == 0)
	    {
		// service is running, restart it
		string start_command = sformat("/etc/init.d/%1 restart", servicename);
		string confirm = sformat(_("Service %1 will be restarted"), servicename);
		string label = sformat(_("Restarting service %1..."), servicename);
		string error = sformat(_("Restart of the service %1 failed"), servicename);

		if (StartCommand(start_command, label, error, confirm, ConfirmActions) == `abort)
		{
		    abort = true;
		}
	    }
	}
	);
    }

    if (size(Commands) > 0)
    {
	// start generic commands
	foreach(string cmd, boolean dummy, Commands,
	``{
	    y2milestone("Command: %1", cmd);
	    Progress::NextStep();

	    if (size(cmd) > 0)
	    {
		string confirm = _("A command will be executed");
		string label = sformat(_("Starting command: %1..."), cmd);
		string error = sformat(_("Command %1 failed"), cmd);

		if (StartCommand(cmd, label, error, confirm, ConfirmActions) == `abort)
		{
		    abort = true;
		}
	    }
	}
	);
    }

    if (abort) return false;

    // set 100% in progress bar
    Progress::NextStep();
    Progress::Title(_("Finished"));

    // set "finished" mark for the last stage
    Progress::NextStage();

    return ret;
}

/**
 * Set all sysconfig settings from the list and read information from files
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global define boolean Import (list settings) ``{
    // set values in the list
    Set(settings);

    // register agent for user defined files, read values
    return Sysconfig::Read(custom_files);
}

/**
 * Set all sysconfig settings from the list
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be set.
 */
global define void Set(list settings) ``{
    if (settings != nil)
    {
	modified_variables = $[];
	custom_files = configfiles;

	// convert from 8.1 export format
	foreach(map setting, settings,
	    ``{
		string n = setting["sysconfig_key"]:"";
		string f = setting["sysconfig_path"]:"";
		string v = setting["sysconfig_value"]:"";

		// compatibility mode for older release with relative path
		if (findfirstof(f, "/") != 0)
		{
		    f = sformat("/etc/sysconfig/%1", f);
		}

		string key = sformat("%1$%2", n, f);

		modified_variables = add(modified_variables, key, v);

		// add configuration file if it isn't already specified
		if (!contains(custom_files, f))
		{
		    custom_files = add(custom_files, f);
		}
	    }
	);
    }
}

/**
 * Dump the sysconfig settings to a single map
 * (For use by autoinstallation.)
 * @return list Dumped settings (later acceptable by Import ())
 */
global define list Export () ``{
    // return structured map (for 8.1 compatibility)

    list ret = [];

    if (size(modified_variables) > 0)
    {
	foreach(string varid, string val, modified_variables,
	    ``{
		string n = get_name_from_id(varid);
		string f = get_file_from_id(varid);

		map m = $[
		    "sysconfig_key"   : n,
		    "sysconfig_path"  : f,
		    "sysconfig_value" : val
		];

		ret = add(ret, m);
	    }
	);
    }

    return ret;
}

/**
 * Create a textual summary
 * @return summary of the current configuration
 */
global define list Summary() ``{
    // configuration summary headline
    string summary = Summary::AddHeader("", _("Configuration Summary"));

    y2milestone("Summary: %1", modified_variables);

    if (size(modified_variables) > 0)
    {
	foreach(string varid, string newval, modified_variables,
	    ``{
		string varnam = get_name_from_id(varid);
		string filename = get_file_from_id(varid);

		summary = Summary::AddLine(summary, sformat("%1=\"%2\" (%3)", varnam, newval, filename));
	    }
	);
    }
    else
    {
	summary = Summary::AddLine(summary, Summary::NotConfigured());
    }

    return summary;
}

define symbol ConfirmationDialog(string message, string command) ``{
    UI::OpenDialog(
	`opt(`decorated),
	`VBox(
	    `Label(message),
	    (size(command) > 0) ? `Label(_("Command: ") + command) : `Empty(),
	    `VSpacing(0.5),
	    `HBox(
		`PushButton(`id(`cont), Label::ContinueButton()),
		// button label
		`PushButton(`id(`skip), _("S&kip")),
		`PushButton(`id(`abort), Label::AbortButton())
	    )
	)
    );

    symbol ret = nil;

    while (ret != `cont && ret != `skip && ret != `abort)
    {
	ret = UI::UserInput();

	if (ret == `close)
	{
	    ret = `abort;
	}
    }

    UI::CloseDialog();

    return ret;
}

define symbol StartCommand(string start_command, string label, string error, string confirm, boolean confirmaction) ``{
    if (size(start_command) == 0)
    {
	return `success;
    }

    // set progress bar label
    Progress::Title(label);

    if (confirmaction == true)
    {
	// show confirmation dialog
	symbol input = ConfirmationDialog(confirm, start_command);

	if (input != `cont)
	{
	    return input;
	}
    }

    y2milestone("Starting: %1", start_command);

    map output = SCR::Execute(.target.bash_output, start_command);
    integer exit = output["exit"]:0;
    y2milestone("Result: %1", exit);

    if (exit != 0)
    {
	Report::Error(error);
	return `failed;
    }

    return `success;
}

/* EOF */
}
