/**
 * File:	modules/Sysconfig.ycp
 * Package:	Configuration of sysconfig
 * Summary:	Data for configuration of sysconfig, input and output functions.
 * Authors:	Ladislav Slezak <lslezak@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of sysconfig.
 * Input and output routines.
 */

{

module "Sysconfig";
textdomain "sysconfig";

import "Progress";
import "Report";
import "Summary";
import "Directory";

include "sysconfig/routines.ycp";
include "network/ip.ycp";

/**
 * Abort function
 * return boolean return true if abort
 */
global block AbortFunction = nil;

global list configfiles = ["/etc/sysconfig/*", "/etc/sysconfig/network/ifcfg-*",
    "/etc/sysconfig/network/wireless", "/etc/sysconfig/network/dhcp",
    "/etc/sysconfig/network/config", Directory::ydatadir + "/descriptions"];

// all read variables
map variables = $[];

// modified variables
map modified_variables = $[];

// comment for non-variable nodes
map node_comments = $[];

// location for each variable
map variable_locations = $[];

global list tree_content = [];

global boolean powertweak_mode = false;

/**
 * Data was modified?
 * @return true if modified
 */
global define boolean Modified() ``{
    return (size(modified_variables) > 0);
};

/**
 * Search in syscnfig files for value
 * @param params search parameters
 * @param show_progress if true progress bar will be displayed
 * @return list(string) List of found variables (IDs)
 */
global define list(string) search(map params, boolean show_progress) ``{
    list(string) found = [];

    // get all configuration files
    list(string) files = SCR::Dir(.syseditor.section);

    if (show_progress == true)
    {
	// Translation: Progress bar label
	UI::OpenDialog(`ProgressBar(`id(`progress), _("Searching..."), size(files), 0));
    }

    boolean search_varname = params["varname"]:true;
    boolean search_description = params["description"]:false;
    boolean search_value = params["value"]:false;
    boolean case_insensitive = params["insensitive"]:false;
    string search_string = params["search"]:"";

    if (search_string == "")
    {
	return found;
    }

    if (case_insensitive == true)
    {
	search_string = tolower(search_string);
    }

    integer index = 0;

    foreach(string file, files, ``{
	    // get all variables in file
	    path var_path = add(.syseditor.value, file);
	    list variables = SCR::Dir(var_path);

	    y2debug("Searching in file %1", file);

	    foreach(string var, variables,
		``{
		    boolean already_found = false;

		    y2debug("Searching in variable %1", var);

		    if (search_varname == true)
		    {
			string var2 = var;
			if (case_insensitive)
			{
			    var2 = tolower(var);
			}

			if (issubstring(var2, search_string))
			{
			    found = add(found, var + "$" + file);
			    already_found = true;
			}
		    }

		    // search in variable value if it is requested and previous check was unsuccessful
		    if (search_value == true && already_found == false)
		    {
			string read_value = SCR::Read(add(add(.syseditor.value, file), var));

			if (case_insensitive)
			{
			    read_value = tolower(read_value);
			}

			if (issubstring(read_value, search_string))
			{
			    found = add(found, var + "$" + file);
			    already_found = true;
			}
		    }

		    if (search_description == true && already_found == false)
		    {
			// read comment without metadata
			string read_comment = get_only_comment(SCR::Read(add(add(.syseditor.value_comment, file), var)));

			if (case_insensitive)
			{
			    read_comment = tolower(read_comment);
			}

			if (issubstring(read_comment, search_string))
			{
			    found = add(found, var + "$" + file);
			}
		    }
		}
	    );

	    if (show_progress == true)
	    {
		index = index + 1;
		UI::ChangeWidget(`id(`progress), `Value, index);
	    }

	}
    );

    if (show_progress == true)
    {
	UI::CloseDialog();
    }

    y2debug("Found: %1", found);

    return found;
}

/**
 * Remove white spaces at beginning or at the end of string
 * @param input Input string
 * @return string String without white spaces
 */
global define string remove_whitespaces(string input) ``{
    if (input == nil)
    {
	return nil;
    }

    string removed_whitespaces = regexpsub(input, "^[ \t]*(([^ \t]*[ \t]*[^ \t]+)*)[ \t]*$", "\\1");

    return (removed_whitespaces != nil) ? removed_whitespaces : input;
}

/**
 * Parse string of possible values
 * @param options Input string
 * @return list List of strings
 */
global define list parse_options(string options) ``{
    list ret = [];

    // parsing possible values is done by two alghorithms:
    // first is much faster, but only usable if string
    // doesn't contain any double qoute characters
    // second is more general, but of course slower

    if (options == nil)
    {
	return [];
    }

    if (findfirstof(options, "\"") == nil)
    {
	// easy case - no qouting, split string to values
	list(string) values = splitstring(options, ",");

	foreach (string v, values, ``{
		v = remove_whitespaces(v);
		if (!contains(ret, v)) ret = add(ret, v);
	    }
	);
    }
    else
    {
	// quoting is used, we cannot easily split input
	// parsing each character is needed
	symbol state = `out_of_string;
	integer index = 0;
	string str = "";

	while(index < size(options))
	{
	    string character = substring(options, index, 1);

	    y2debug("character: %1 state: %2 index: %3", character, state, index);

	    if (character == "\\")
	    {
		if (index + 1 < size(options))
		{
		    string nextcharacter = substring(options, index + 1, 1);

		    if (nextcharacter == "\"")
		    {
			character = "\\\"";
			index = index + 1;
		    }
		}
	    }

	    if (state == `out_of_string)
	    {
		if (character == " " || character == "\t" || character == ",")
		{
		    index = index + 1;
		    continue;
		}
		else if (character == "\"")
		{
		    state = `in_quoted_string;
		}
		else
		{
		    state = `in_string;

		    if (character == "\\\"")
		    {
			str = "\"";
		    }
		    else
		    {
			str = character;
		    }
		}
	    }
	    else if (state == `in_quoted_string)
	    {
		if (character == "\"")
		{
		    state = `out_of_string;
		    if (!contains(ret, str)) ret = add(ret, str);
		    str = "";
		}
		else if (character == "\\\"")
		{
		    str = str + "\"";
		}
		else
		{
		    str = str + character;
		}
	    }
	    else if (state == `in_string)
	    {
		if (character == ",")
		{
		    state = `out_of_string;
		    str = remove_whitespaces(str);
		    if (!contains(ret, str)) ret = add(ret, str);
		    str = "";
		}
		else if (character == "\\\"")
		{
		    str = str + "\"";
		}
		else
		{
		    str = str + character;
		}
	    }

	    index = index + 1;
	}

	if (state == `in_quoted_string)
	{
	    y2warning("Missing trainling double quote character(\") in input: '%1'", options);
	    if (!contains(ret, str)) ret = add(ret, str);
	}

	if (state == `in_string)
	{
	    str = remove_whitespaces(str);
	    if (!contains(ret, str)) ret = add(ret, str);
	}
    }

    y2debug("Parsed values: %1", ret);

    return ret;
}

/**
 * Get description of selected variable
 * @param varid Variable identification
 * @return map Description map
 */

global define map get_description(string varid) ``{
    string varname = get_name_from_id(varid);
    string fname = get_file_from_id(varid);

    path comment_path = add(add(.syseditor.value_comment, fname), varname);
    path value_path = add(add(.syseditor.value, fname), varname);
    string comment = SCR::Read(comment_path);

    // no comment present
    if (size(comment) == 0 && !regexpmatch(fname, "^/etc/sysconfig/network/ifcfg-.*"))
    {
	y2warning("Comment for variable %1 is missing", varid);

	list all_variables = SCR::Dir(add(.syseditor.value, fname));
	list reversed = [];

	integer i = 0;
	boolean found = false;

	while (i < size(all_variables) && found == false)
	{
	    string v = all_variables[i]:"";

	    if (v == varname)
	    {
		found = true;
	    }
	    else
	    {
		reversed = prepend(reversed, v);
	    }

	    i = i + 1;
	}

	if (found == true)
	{
	    i = 0;
	    comment = "";
	    string v = "";

	    y2debug("reversed: %1", reversed);
	    while (i < size(reversed) && comment == "")
	    {
		v = reversed[i]:"";
		comment = SCR::Read(add(add(.syseditor.value_comment, fname), v));

		i = i + 1;
	    }

	    y2warning("Variable: %1 Using comment from variable: %2", varname, v);
	}

    }

    map meta = parse_metadata(comment);

    string template_only_comment = "";

    // for network configuration file read comments from configuration template
    if (regexpmatch(fname, "^/etc/sysconfig/network/ifcfg-.*"))
    {
	string template_comment = SCR::Read(add(add(.sysconfig.network.template, "value_comment"), varname));
	map template_meta = parse_metadata(template_comment);

	if (size(template_meta) > 0)
	{
	    // add missing metadata values from template
	    foreach(string key, string value, template_meta, ``{
		    if (!haskey(meta, key))
		    {
			meta[key] = value;
		    }
		}
	    );

	    template_only_comment = get_only_comment(template_comment);

	    if (size(template_only_comment) > 0)
	    {
		template_only_comment = template_only_comment + "<BR><BR>";
	    }
	}

	y2milestone("Meta read from template: %1", template_meta);
    }

    string deflt = meta["Default"]:nil;

    if (deflt != nil)
    {
	list parsed = parse_options(deflt);
	meta["Default"] = parsed[0]:deflt;
    }

    string new_value = modified_variables[varid]:nil;

    // check if value was changed
    if (new_value != nil)
    {
	meta["new_value"] = new_value;
    }

    meta["name"] = varname;
    meta["file"] = get_file_from_id(varid);
    meta["location"] = (varname != "") ? get_location_from_id(varid) : varid;
    meta["comment"] = (varname != "") ? template_only_comment + get_only_comment(comment) : (node_comments[varid]:"");
    meta["value"] = SCR::Read(value_path);

    return meta;
}

/**
 * Parse metadata from comment
 * @param comment Input comment
 * @return map parsed metadata
 */
global define map parse_metadata(string comment) ``{
    map ret = $[];

    // get metadata part of comment
    list metalines = get_metadata(comment);
    list joined_multilines = [];
    string multiline = "";

    y2debug("metadata: %1", metalines);

    // join multi line metadata lines
    foreach(string metaline, metalines, ``{
	    if (substring(metaline, size(metaline) - 1, 1) != "\\")
	    {
		if (multiline != "")
		{
		    // this not first multiline so remove comment mark
		    string without_comment = regexpsub(metaline, "^##(.*)", "\\1");

		    if (without_comment != nil)
		    {
			metaline = without_comment;
		    }
		}
		joined_multilines = add(joined_multilines, multiline + metaline);
		multiline = "";
	    }
	    else
	    {
		string part = substring(metaline, 0, size(metaline) - 1);

		if (multiline != "")
		{
		    // this not first multiline so remove comment mark
		    string without_comment = regexpsub(part, "^##(.*)", "\\1");

		    if (without_comment != nil)
		    {
			part = without_comment;
		    }
		}

		// add line to the previous lines
		multiline = multiline + part;
	    }
	}
    );

    y2debug("metadata after multiline joining: %1", joined_multilines);

    // parse each metadata line
    foreach(string metaline, joined_multilines, ``{

	    /* Ignore lines with ### -- general comments */
	    if (regexpmatch(metaline, "^###"))
	    {
		return;
	    }

	    string meta = regexpsub(metaline, "^##[ \t]*(.*)", "\\1");

	    // split sting to the tag and value part
	    integer colon_pos = findfirstof(meta, ":");
	    string tag = "";
	    string val = "";

	    if (colon_pos == nil)
	    {
		// colon is missing
		tag = meta;
	    }
	    else
	    {
		tag = substring(meta, 0, colon_pos);

		if (size(meta) > colon_pos + 1)
		{
		    val = substring(meta, colon_pos + 1);
		}
	    }

	    // remove whitespaces from parts
	    tag = remove_whitespaces(tag);
	    val = remove_whitespaces(val);

	    y2milestone("tag: %1 val: '%2'", tag, val);

	    // add tag and value to map if they are present in comment
	    if (tag != "")
	    {
		ret = add(ret, tag, val);
	    }
	    else
	    {
		// ignore separator lines
		if (!regexpmatch(metaline, "^#*$"))
		{
		    y2warning("Unknown metadata line: %1", metaline);
		}
	    }
	}
    );

    return ret;
}

/**
 * Get metadata lines from input string
 * @param input Input string
 * @return list(string) Metadata lines in list
 */
global define list(string) get_metadata(string input) ``{
    if (input == nil || input == "")
    {
	return [];
    }

    list(string) lines = splitstring(input, "\n");
    return (filter(string line, lines, ``(regexpmatch(line, "^##.*"))));
}

/**
 * Get comment without metadata
 * @param input Input string
 * @return string Comment used as variable descriprion
 */
global define string get_only_comment(string input) ``{
    if (input == nil || input == "")
    {
	return "";
    }

    list(string) lines = splitstring(input, "\n");

    string ret = "";

    foreach(string line, lines, ``{
	    string com_line = regexpsub(line, "^#([^#].*)", "\\1");

	    if (com_line != nil)
	    {
		com_line = regexpsub(com_line, "^[ \t]*(.*)", "\\1");
	    }

	    if (com_line != nil)
	    {
		ret = ret + com_line + " ";
	    }
	}
    );

    return ret;
}

/**
 * Get variable name from variable identification or empty string if input is invalid
 * @param id Variable identification
 * @return string Variable name
 * @example get_name_from_id("var$file") -> "var"
 */
global define string get_name_from_id(string id) ``{

    if (id == nil)
    {
	return "";
    }

    integer pos = findfirstof(id, "$");

    if (pos >= 0)
    {
	return substring(id, 0, findfirstof(id, "$"));
    }
    else
    {
	return "";
    }
}

/**
 * Get variable location in tree widget from variable identification
 * @param id Variable identification
 * @return string Variable location
 */
global define string get_location_from_id(string id) ``{
    return variable_locations[id]:"";
}

/**
 * Get file name where is variable located from variable identification
 * @param id Variable identification
 * @return string File name
 */
global define string get_file_from_id(string id) ``{
    if (id == nil)
    {
	return "";
    }

    integer pos = findfirstof(id, "$");

    if (pos >= 0)
    {
	return substring(id, pos + 1);
    }
    else
    {
	return "";
    }
}

/**
 * Set new variable value
 * @param variable Variable identification
 * @param new_value New value
 * @param force If true - do not check if new value is valid
 * @param force_change Force value as changed even if it is equal to old value
 * @return symbol Result: `not_found (specified variable was not found in config file),
 *   `not_valid (new  value is not valid - doesn't match variable type definition),
 *   `ok (success)
 */
global define symbol set_value(string variable, string new_value, boolean force, boolean force_change) ``{
    map desc = get_description(variable);
    string name = get_name_from_id(variable);

    if (name == "")
    {
	return `not_found;
    }

    string modif = modified_variables[variable]:nil;
    string old = desc["value"]:"";

    string curr_val = (modif != nil) ? modif : old;

    if (force_change || new_value != curr_val)
    {
	y2milestone("variable: %1 changed from: %2 to: %3", variable, curr_val, new_value);

	if (new_value == old && !force_change)
	{
	    // variable was reset to the original value, remove it from map of modified
	    y2debug("Variable %1 was reset to the original value", variable);
	    modified_variables = remove(modified_variables, variable);
	}
	else
	{
	    boolean valid = false;

	    if (force == false)
	    {
		// check data type
		string type = desc["Type"]:"string";

		if (type == "string" || regexpmatch(type, "^string\\(.*\\)$") == true)
		{
		    // string type is valid always
		    valid = true;
		}
		else if (type == "yesno")
		{
		    valid = (new_value == "yes" || new_value == "no");
		}
		else if (type == "boolean")
		{
		    valid = (new_value == "true" || new_value == "false");
		}
		else if (type == "integer")
		{
		    valid = regexpmatch(new_value, "^-{0,1}[0-9]*$");

		}
		else if (regexpmatch(type, "^list\\(.*\\)$"))
		{
		    string listopt = regexpsub(type, "^list\\((.*)\\)$", "\\1");
		    list parsed_opts = parse_options(listopt);

		    valid = contains(parsed_opts, new_value);
		}
		else if (regexpmatch(type, "^integer\\(-{0,1}[0-9]*:-{0,1}[0-9]*\\)$"))
		{
		    // check if input is integer
		    valid = regexpmatch(new_value, "^-{0,1}[0-9]*$");

		    if (valid == true)
		    {
			// it is integer, check range
			string min = regexpsub(type, "^integer\\((-{0,1}[0-9]*):-{0,1}[0-9]*\\)$", "\\1");
			string max = regexpsub(type, "^integer\\(-{0,1}[0-9]*:(-{0,1}[0-9]*)\\)$", "\\1");

			y2milestone("min: %1  max: %2", min, max);

			integer min_int = tointeger(min);
			integer max_int = tointeger(max);
			integer new_int = tointeger(new_value);

			y2milestone("min_int: %1  max_int: %2", min_int, max_int);

			if (max_int != nil && min_int != nil)
			{
			    valid = (new_int >= min_int && new_int <= max_int);
			}
			else if (max_int == nil)
			{
			    valid = (new_int >= min_int);
			}
			else if (min_int == nil)
			{
			    valid = (new_int <= max_int);
			}
			else
			{
			    // empty range, valid is set to true
			    y2warning("empty integer range, assuming any integer");
			}
		    }
		}
		else if (regexpmatch(type, "^regexp\\(.*\\)$"))
		{
		    string regex = regexpsub(type, "^regexp\\((.*)\\)$", "\\1");
		    valid = regexpmatch(new_value, regex);
		}
		else if (type == "ip")
		{
		    // check IP adress using function from network/ip.ycp include
		    valid = check_ip(new_value);
		}
		else if (type == "ip4")
		{
		    // check IP adress using function from network/ip.ycp include
		    valid = check_ip4(new_value);
		}
		else if (type == "ip6")
		{
		    // check IP adress using function from network/ip.ycp include
		    valid = check_ip6(new_value);
		}
		else
		{
		    y2warning("Unknown data type %1 for variable %2", type, name);
		}
	    }

	    if (valid == false && force == false)
	    {
		return `not_valid;
	    }
	    else
	    {
		modified_variables[variable] = new_value;
		return `ok;
	    }
	}
    }
}

/**
 * Return modification status of variable
 * @param varid Variable identification
 * @return boolean True if variable was modified
 */
global define boolean modified(string varid) ``{
    return haskey(modified_variables, varid);
}

/**
 * Get list of modified variables
 * @return list List of modified variables
 */
global define list get_modified()
``{

    list ret = [];

    foreach(string varid, string new_value, modified_variables,
	``{
	    ret = add(ret, varid);
	}
    );

    return ret;
}

/**
 * Read all sysconfig settings
 * @param files list of files or directories to read. Directories are not read recursively.
 * @return true on success
 */
global define boolean Read(list(string) files) ``{

    string tmpdir = SCR::Read(.target.tmpdir);
    if (tmpdir == nil || tmpdir == "")
    {
	y2security("Using /tmp directory !");
	tmpdir = "/tmp";
    }

    // register configuration files in SCR using INI-agent
    string agentdef = sformat(".syseditor\n\n`ag_ini(IniAgent( %1,\n", files) + SCR::Read(.target.string, Directory::ydatadir + (powertweak_mode ? "/powertweak.agent" : "/sysedit.agent"));
    string tmp = tmpdir + "/sysconfig-agent.scr";

    SCR::Write(.target.string, tmp, agentdef);
    SCR::RegisterAgent(.syseditor, tmp);


    // register agent for reading network template
    agentdef = sformat(".sysconfig.network.template,\n\n`ag_ini(IniAgent(\"/usr/share/doc/packages/sysconfig/ifcfg.template\"\n,") + SCR::Read(.target.string, Directory::ydatadir + "/sysedit.agent");
    tmp = tmpdir + "/sysconfig-template-agent.scr";

    SCR::Write(.target.string, tmp, agentdef);
    SCR::RegisterAgent(.sysconfig.network.template, tmp);


    // list of all config files
    y2milestone("Registered config files: %1", SCR::Dir(.syseditor.section));

    // create script options
    string param = "";
    foreach(string par, files, ``{param = param + "'" + par + "' ";});

    // create tree definition list and description map using external Perl script
    SCR::Execute(.target.bash, Directory::bindir + "/parse_configs.pl " + (powertweak_mode ? "--powertweak " : "") + param + "> " + tmpdir + "/treedef.ycp");

    // read list
    list parsed_output = SCR::Read(.target.ycp, tmpdir + "/treedef.ycp");
    tree_content = parsed_output[0]:[];

    node_comments = parsed_output[1]:$[];

    variable_locations = parsed_output[2]:$[];

    return true;
}

/**
 * Write all sysconfig settings
 * @return true on success
 */
global define boolean Write() ``{

    // write dialog caption
    string caption = _("Saving sysconfig Configuration");

    // set the right number of stages
    integer steps = size(modified_variables);

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	// progress bar item
	    _("Write the settings"),
	], [
	// progress bar item
	    _("Writing the settings..."),
	// progress bar item
	    _("Finished")
	],
	""
    );

    // save each changed variable
    foreach (string vid, string new_val, modified_variables,
	``{
	    string file = get_file_from_id(vid);
	    string name = get_name_from_id(vid);
	    path value_path = add(add(.syseditor.value, file), name);

	    SCR::Write(value_path, new_val);
	    Progress::NextStep();
	}
    );

    // flush changes
    SCR::Write(.syseditor, nil);

    return true;
}

/**
 * Get all sysconfig settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global define boolean Import (list settings) ``{

    modified_variables = $[];
    list files = configfiles;

    // convert from 8.1 export format
    foreach(map setting, settings,
	``{
	    string n = setting["sysconfig_key"]:"";
	    string f = setting["sysconfig_path"]:"";
	    string v = setting["sysconfig_value"]:"";

		// compatibility mode for older release with relative path
		if (findfirstof(f, "/") != 0)
			f = sformat("/etc/sysconfig/%1", f);
	    string key = sformat("%1$%2", n, f);

	    modified_variables = add(modified_variables, key, v);

	    // add configuration file if it isn't already specified
	    if (!contains(files, f))
	    {
		files = add(files, f);
	    }
	}
    );

    // register agent for user defined files, read values
    return Sysconfig::Read(files);
}

/**
 * Dump the sysconfig settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global define list Export () ``{
    // return structured map (for 8.1 compatibility)

    list ret = [];

    if (size(modified_variables) > 0)
    {
	foreach(string varid, string val, modified_variables,
	    ``{
		string n = get_name_from_id(varid);
		string f = get_file_from_id(varid);

		map m = $[
		    "sysconfig_key"   : n,
		    "sysconfig_path"  : f,
		    "sysconfig_value" : val
		];

		ret = add(ret, m);
	    }
	);
    }

    return ret;
}

/**
 * Create a textual summary
 * @param split split configured and unconfigured?
 * @return summary of the current configuration
 */
global define list Summary() ``{
    // configuration summary headline
    string summary = Summary::AddHeader("", _("Configuration Summary"));

    y2milestone("Summary: %1", modified_variables);

    if (size(modified_variables) > 0)
    {
	foreach(string varid, string newval, modified_variables,
	    ``{
		string varnam = get_name_from_id(varid);
		string filename = get_file_from_id(varid);

		summary = Summary::AddLine(summary, sformat("%1=\"%2\" (%3)", varnam, newval, filename));
	    }
	);
    }
    else
    {
	summary = Summary::AddLine(summary, Summary::NotConfigured());
    }

    return summary;
}


/* EOF */
}
